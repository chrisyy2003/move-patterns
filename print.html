<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Move Patterns: Design Patterns for Resource Based Programming</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Book on software design patterns for Move smart contract programming language.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Design Patterns</li><li class="chapter-item expanded "><a href="capability.html"><strong aria-hidden="true">1.</strong> Capability</a></li><li class="chapter-item expanded "><a href="wrapper.html"><strong aria-hidden="true">2.</strong> Wrapper</a></li><li class="chapter-item expanded "><a href="witness.html"><strong aria-hidden="true">3.</strong> Witness</a></li><li class="chapter-item expanded "><a href="hot-potato.html"><strong aria-hidden="true">4.</strong> Hot Potato</a></li><li class="chapter-item expanded "><a href="multiple-configurations.html"><strong aria-hidden="true">5.</strong> Multiple Configurations</a></li><li class="chapter-item expanded "><a href="accountless-design.html"><strong aria-hidden="true">6.</strong> Accountless Design</a></li><li class="chapter-item expanded "><a href="script-based-design.html"><strong aria-hidden="true">7.</strong> Script Based Design</a></li><li class="chapter-item expanded "><a href="transferable-witness.html"><strong aria-hidden="true">8.</strong> Transferable Witness</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Move Patterns: Design Patterns for Resource Based Programming</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/chrisyy2003/move-patterns" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="介绍"><a class="header" href="#介绍">介绍</a></h1>
<p>Move是一种安全、沙盒式和形式化验证的下一代编程语言，它的第一个用例是<a href="https://en.wikipedia.org/wiki/Diem_(digital_currency)">Diem</a>区块链（当时名字叫Libra, 脸书团队开发的项目, 译者注）,Move为其实现提供了基础。 Move 允许开发人员编写灵活管理和转移数字资产的程序，同时提供安全保护，防止对那些链上资产的攻击。不仅如此，Move 也可用于区块链世界之外的开发场景。</p>
<p>Move 的诞生从<a href="https://www.rust-lang.org/">Rust</a>中吸取了灵感，Move也是因为使用具有移动（move）语义的资源类型作为数字资产（例如货币）的显式表示而得名。</p>
<p>今天，Move 及其虚拟机正在为 <a href="https://github.com/MystenLabs/awesome-move#move-powered-blockchains">多个区块链</a> 提供动力，其中大部分仍处于早期开发阶段。</p>
<h2 id="什么是move-patterns"><a class="header" href="#什么是move-patterns">什么是Move Patterns</a></h2>
<p>本书旨在讨论面向资源的语言的软件设计模式和最佳实践，尤其是Move及其风格。这部分涵盖了 Move 中广泛使用的编程模式，为什么会存在Move设计模式，主要有以下三个方面。</p>
<ul>
<li>
<p>面向资源编程
Move是一种新的编程语言，其特点是面向资源编程，对于区块链最核心的 Token 资产进行了更为贴合的处理，实现了真正意义上的数字资产化。Move与传统面向对象的编程语言有着很大不同，所以一些面向对象的设计模式在Move中是不存在的（例如Uniswap中的工厂模式）。当然，这些模式中的一些很可能也可以在其他一些基于资源的语言和生态系统中实现。</p>
</li>
<li>
<p>状态存储机制
在Solidity中，能够定义并保存自己的状态变量，变量的值放在全局储存上，在合约中可以直接通过全局变量直接读取或者修改它。</p>
<pre><code class="language-solidity">// A solidity examply
// set msg.sender to owner
contract A {
    // 定义一个状态变量
    address owner;
    function setOwner() public {
	// 通过变量名直接修改
        owner = msg.sender;
    }
}
</code></pre>
<p>但是在Move中存储方式是完全不一样的，Move合约并不直接存储资源，代码中的每一个变量都是一个资源对象，是资源对象那么必须通过显示的接口去明确的调用。</p>
<p>Move中对资源的访问都是通过<a href="http://movebook.chrisyy.top/global-storage-operators.html">全局存储操作</a>接口来访问的。操作函数包括<code>move_to</code>或者<code>move from</code>或者<code>borrow_global</code>，<code>borrow_global_mut</code>等函数。从全局储存里面取出资源，或者存放到账户下去，引用资源对象或者修改，都是需要<strong>要开发者显示的去表示。</strong></p>
<pre><code class="language-move">module example::m {
    // A Coin type
    // 一种Coin类型的资源
    struct Coin has key, store{
        value: u64
    }
    // send sender a coin value of 100
    // 在sender地址下存放100个coin
    public entry fun mint(sender: &amp;signer) {
        move_to(sender, Coin {
            value: 100
        });
    }
}
</code></pre>
</li>
<li>
<p>Ability 
Ability是 Move 语言中的一种类型特性，用于控制对给定类型的值允许哪些操作。</p>
<ul>
<li><a href="http://movebook.chrisyy.top/abilities.html#copy">copy</a>复制：允许此类型的值被复制</li>
<li><a href="http://movebook.chrisyy.top/abilities.html#drop">drop</a> 丢弃：允许此类型的值被弹出/丢弃，没有话表示必须在函数结束之前将这个值销毁或者转移出去。</li>
<li><a href="http://movebook.chrisyy.top/abilities.html#store">store</a> 存储：允许此类型的值存在于全局存储中或者某个结构体中</li>
<li><a href="http://movebook.chrisyy.top/abilities.html#key">key</a> 键值：允许此类型作为全局存储中的键(具有 <code>key</code> 能力的类型才能保存到全局存储中)</li>
</ul>
</li>
</ul>
<p>作为面向资源的编程语言，以上三个特点也是与其他语言非常不同的地方，基于资源编程的Move编程模式，也主要是围绕这些特性产生的。</p>
<p>此外本书不是 Move 或任何其他面向资源的语言的指南。 有关 Move 本身的书籍，请参阅 <a href="https://github.com/MystenLabs/awesome-move#books">awesome-move#books</a>。 另请参阅 <a href="https://github.com/MystenLabs/awesome-move">awesome-move</a> 以获取来自 Move 编程语言社区的代码和内容的精选列表。</p>
<h2 id="technical-disclaimer"><a class="header" href="#technical-disclaimer">Technical disclaimer</a></h2>
<p>This book is designed to be viewed digitally with hyperlink support (such as PDF or web format). For now the <a href="https://en.wikipedia.org/wiki/Software_design_pattern#Documentation">full software pattern format</a> is not followed, instead the patterns are simply defined by a short summary and examples.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p><a href="https://creativecommons.org/licenses/by/4.0/" title="Creative Commons Attribution 4.0 International License"><img src="https://mirrors.creativecommons.org/presskit/buttons/88x31/svg/by.svg" alt="CC BY 4.0 license button" title="CC BY 4.0 license button" /></a></p>
<p>Move Patterns: Design Patterns for Resource Based Programming © 2022 by <a href="https://github.com/villesundell">Ville Sundell</a> is licensed under CC BY 4.0. To view a copy of this license, visit <a href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="capability"><a class="header" href="#capability">Capability</a></h1>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Name</strong></td><td>Capability</td></tr>
<tr><td><strong>Origin</strong></td><td><a href="https://github.com/move-language/move/blob/5e034dde19a5320d7e2bdc9da25114e816b4454d/language/stdlib/modules/libra_coin.mvir#L8">Libra Project</a> / Unknown Author</td></tr>
<tr><td><strong>Example</strong></td><td><a href="https://examples.sui.io/patterns/capability.html">Sui Move by Example</a> / <a href="https://github.com/damirka">Damir Shamanaev</a></td></tr>
<tr><td><strong>Depends on</strong></td><td>None</td></tr>
<tr><td><strong>Known to work on</strong></td><td>Move</td></tr>
</tbody></table>
</div>
<h2 id="概述"><a class="header" href="#概述">概述</a></h2>
<p>Capability是一个能够证明<strong>资源所有者</strong>特定权限的资源（注意：它是一个资源也就是一个Move中的结构体），其作用主要是用来进行访问控制。</p>
<p>例如当我们想限制某个资源的铸造权，管理权，函数调用权时，便可以采用Capability这种设计模式。这也是Move智能合约里面使用最广泛的一个设计模式，例如sui-framework中的<a href="https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/sources/coin.move#L32-L35">TreasuryCap</a>。这是也是已知最古老的 Move 设计模式，可追溯到 Libra 项目及其代币智能合约，其中功能用于授权铸币。</p>
<h2 id="如何使用"><a class="header" href="#如何使用">如何使用</a></h2>
<p>Capability本质是一个资源对象，只是被可信任的用户持有。通常在合约中我们可以定义一个<code>AdminCap</code>来代表本模块的控制权限，如果某个用户持有就可以用户可信，其中资源对象内不需要任何的字段。</p>
<pre><code class="language-move">struct AdminCap has key, store {}
</code></pre>
<p>一般Capability生成在模块初始化的时候，例如Sui中的init函数，就可以赋予部署者一个Capability的资源，然后通过<code>move_to</code>然后储存到它的账户下。</p>
<p>然后当需要使用到有访问权限的函数时，此时函数就会检查调用者地址下是否存在这个Capability资源，如果存在那么说明调用者拥有正确的访问权限。</p>
<h3 id="aptos"><a class="header" href="#aptos">Aptos</a></h3>
<pre><code class="language-move">module example::capability {
    use std::signer;

    // 定义一个OwnerCapability类型
    struct OwnerCapability has key, store {}

    // 向管理者地址下存放一个OwnerCapability资源
    public entry fun init(sender: signer) {
        assert!(signer::address_of(&amp;sender) == @example, 0);
        move_to(&amp;sender, OwnerCapability {})
    }

    // Only user with OwnerCapability can call this function
    // 只有具有OwnerCapability的用户才能调用此函数
    public entry fun admin_fun(sender: &amp;signer) acquires OwnerCapability {
        assert!(exists&lt;OwnerCapability&gt;(signer::address_of(sender)), 1);
        let _cap = borrow_global&lt;OwnerCapability&gt;(signer::address_of(sender));
        // do something with the cap.
    }
}
</code></pre>
<h3 id="sui"><a class="header" href="#sui">Sui</a></h3>
<p>sui中的Move与Aptos或者starcoin中的Core Move有所不同，sui封装了全局操作函数，具体可以查看sui的<a href="https://docs.sui.io/learn/sui-move-diffs">官方文档</a>。</p>
<pre><code class="language-move">module capability::m {
    use sui::transfer;
    use sui::object::{Self, UID};
    use sui::tx_context::{Self, TxContext};

    struct OwnerCapability has key { id: UID }

    /// A Coin Type
    struct Coin has key, store {
        id: UID,
        value: u64
    }

    /// Module initializer is called once on module publish.
    /// Here we create only one instance of `OwnerCapability` and send it to the publisher.
    fun init(ctx: &amp;mut TxContext) {
        transfer::transfer(OwnerCapability {
            id: object::new(ctx)
        }, tx_context::sender(ctx))
    }

    /// The entry function can not be called if `OwnerCapability` is not passed as
    /// the first argument. Hence only owner of the `OwnerCapability` can perform
    /// this action.
    public entry fun mint_and_transfer(
        _: &amp;OwnerCapability, to: address, ctx: &amp;mut TxContext
    ) {
        transfer::transfer(Coin {
            id: object::new(ctx),
            value: 100,
        }, to)
    }
}
</code></pre>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>相较于其他语言的访问控制（例如Solidity中定一个<code>address owner</code>即可，或者定义一个<code>mapping</code>），Move中的访问控制实现上是复杂的，主要由于Move中独特的存储架构，模组不存储状态变量，需要将资源存储到一个账户下面。</p>
<p>但是单单对于对于访问控制来说，实现方式有很多种，例如在Move中可以使用<code>VecMap</code>等数据结构达到同样的效果，但是Capability这种模式跟面向资源编程的概念更加契合且容易使用。</p>
<blockquote>
<p>需要注意的是，既然Capability作为一个凭证，显然是不能<code>copy</code>的能力的，如果别人拿到<code>copy</code>之后，它可以通过复制从而获得更多的Capability。同样在正常的业务逻辑下，Capability也是不能随意的丢弃也就是不能有<code>drop</code>能力，因为丢弃的话显然会造成一些不可逆的影响。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrapper"><a class="header" href="#wrapper">Wrapper</a></h1>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Name</strong></td><td>Wrapper</td></tr>
<tr><td><strong>Origin</strong></td><td><a href="https://github.com/villesundell">Ville Sundell</a></td></tr>
<tr><td><strong>Example</strong></td><td><a href="https://github.com/taoheorg/taohe">TaoHe project</a></td></tr>
<tr><td><strong>Depends on</strong></td><td>None</td></tr>
<tr><td><strong>Known to work on</strong></td><td>Move</td></tr>
</tbody></table>
</div>
<h2 id="概述-1"><a class="header" href="#概述-1">概述</a></h2>
<p>Wrapper是将一个对象嵌套在另一个对象的模式。例如在上个Capability的例子中，通常合约初始化时会铸造一个Capability，那么在这之后如果我想将这个Capability转让给其他人怎么办？</p>
<p>在Move中我们往一个地址下存放数据时，会使用到<code>move_to</code>函数，但是此函数接受的参数是<code>signer</code>，也就是没有账号的签名发起的交易是没有办法<strong>主动向地址下存放资源</strong>。所以在Move编程实践的当中就产生了Wrapper这么一个模式。</p>
<p>Wrapper模式指的是，如果需要主动给一个地址发送一个资源时，首先把要发送的对象放在一个Wrapper对象里面包装一下，随后用户需要<strong>主动调用</strong>接受Wrapper的函数，此时函数会通过Wrapper这个资源取出来其中被包装的对象，由于是用户主动调用的该函数，所以可以直接存放到用户下面。</p>
<blockquote>
<p>这种场景总主要是因为不能直接发送，所以需要先预把对象，预存到一个地方，然后接受者再主动去确认拿取，就如同现实生活中Offer需要确认一般，所以这种模式一般也叫做Offer模式</p>
</blockquote>
<h2 id="如何使用-1"><a class="header" href="#如何使用-1">如何使用</a></h2>
<h3 id="aptos-1"><a class="header" href="#aptos-1">Aptos</a></h3>
<p>为了实现资源的转移，可以在合约中可以定义一个Offer资源，类型参数接受一个泛型<code>T</code>，从而可以给任意类型包装，然后定义一个<code>receipt</code>字段进行访问控制。</p>
<p>用户接受Offer时，首先从Offer地址下取出来，随后在验证地址是否和Offer中的地址相同。</p>
<pre><code class="language-move">module example::offer {
    use std::signer;

    struct OwnerCapability has key, store {}

    /// 定义一个Offer来包装一个对象
    struct Offer&lt;T: key + store&gt; has key, store {
        receipt: address,
        offer: T,
    }
    /// 发送一个Offer到地址to下
    public entry fun send_offer(sender: &amp;signer, to: address) {
        move_to&lt;Offer&lt;OwnerCapability&gt;&gt;(sender, Offer&lt;OwnerCapability&gt; {
            receipt: to,
            offer: OwnerCapability {},
        });
    }
    /// 地址to调用函数从而接受Offer中的对象
    public entry fun accept_role(sender: &amp;signer, grantor: address) acquires Offer {
        assert!(exists&lt;Offer&lt;OwnerCapability&gt;&gt;(grantor), 0);
        let Offer&lt;OwnerCapability&gt; { receipt, offer: admin_cap } = move_from&lt;Offer&lt;OwnerCapability&gt;&gt;(grantor);
        assert!(receipt == signer::address_of(sender), 1);
        move_to&lt;OwnerCapability&gt;(sender, admin_cap);
    } 
}
</code></pre>
<h3 id="sui-1"><a class="header" href="#sui-1">Sui</a></h3>
<p>Sui中由于资源都是一个Object，每一个对象都是属于一个Owner的，所以需要主动给用户发送资源时，只需要使用<code>transfer::transfer(obj, to)</code>，不需要使用Offer模式</p>
<h2 id="总结-1"><a class="header" href="#总结-1">总结</a></h2>
<p>Wrapper中由于定义了一个<code>receipt</code>字段限制了只能有指定的地址来接受Offer，在其他场景，例如需要赋予多个人一个Capability又如何解决？此外在Move中，一个账户下只能存放一种类型的资源，那么针对上面的情况如果想再存放另外一个人的Offer也是不可行的。</p>
<p>所以在我们实践中，可以将<code>receipt</code>字段替换为一个<code>vector</code>或者一个<code>table</code>来储存多个目标地址。</p>
<pre><code class="language-move">/// 定义一个Offer来包装一个对象
struct Wrapper&lt;T: key + store&gt; has key, store {
    receipt: address,
    map: VecMap&lt;T&gt;,
}
</code></pre>
<hr />
<p>此外在其他场景中如果没有提供存放资源的接口，那么可以通过Wrapper来将其保存。</p>
<p>例如下面的<code>Coin</code>模块，由于Move中的特性，定义的资源只能在定义这个资源的模块内操作，所以当mint函数返回一个<code>Coin</code>对象时，用户不能直接使用<code>move_to</code>来存放。</p>
<pre><code class="language-move">module example::coin {
    struct Coin has key, store {
        value: u64
    }
    struct MintCapability has key, store {}

    public fun mint(amount: u64, _cap: &amp;MintCapability): Coin {
        Coin { value: amount }
    }
}
</code></pre>
<p>那么此时用户可以定义一个自己的Wrapper结构将其包装，随后就可以将这个嵌套结构一同放到自己的地址下。</p>
<pre><code class="language-move">struct Wrapper has key, store {
        coin: Coin
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="witness"><a class="header" href="#witness">Witness</a></h1>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Name</strong></td><td>Witness</td></tr>
<tr><td><strong>Origin</strong></td><td><a href="https://github.com/MystenLabs/sui/blob/c1ed7cc451119432d32d8eacf471f314e0ce5275/fastx_programmability/sources/Coin.move#L85">FastX</a> / <a href="https://github.com/sblackshear">Sam Blackshear</a></td></tr>
<tr><td><strong>Example</strong></td><td><a href="https://examples.sui.io/patterns/witness.html">Sui Move by Example</a> / <a href="https://github.com/damirka">Damir Shamanaev</a></td></tr>
<tr><td><strong>Depends on</strong></td><td>None</td></tr>
<tr><td><strong>Known to work on</strong></td><td>Move</td></tr>
</tbody></table>
</div>
<h2 id="概述-2"><a class="header" href="#概述-2">概述</a></h2>
<p>witness是一种临时资源，相关资源只能被使用一次，资源在使用后被丢弃，确保不能重复使用相同的资源来初始化任何其他结构，通常用来确认一个类型的的所有权。</p>
<p>witness得益于Move中的类型系统。一个类型实例化的时候，它只能在定义这个类型的模块中创建。</p>
<p>一个简单的例子，在framework里面定义了coin合约用来定义token标准，如果想要注册token那么合约会调用<code>publish_coin</code>。</p>
<pre><code class="language-solidity">module framework::coin {
    /// The witness patameter ensures that the function can only be called by the module defined T.
    public fun publish_coin&lt;T: drop&gt;(_witness: T) {
        // register this coin to the registry table
    }
}
module examples::xcoin {
    use framework::coin;
    /// The Witness type.
    struct X has drop {}
    /// Only this module defined X can call framework::publish_coin&lt;X&gt;
    public fun publish() {
        coin::publish_coin&lt;X&gt;(X {});
    }
}
module hacker::hack {
    use framework::coin;
    use examples::xcoin::X;

    public fun publish() {
        // Illegal, X can not be constructed here.
        coin::publish_coin&lt;X&gt;(X {}); 
    }
}
</code></pre>
<p>那么如果此时有一个hacker想要抢先注册这个token，那么需要构造模块中的x提前调用<code>publish_coin</code>函数，但是由于Move中的类型系统限制了这种情况的发生，因为模块外部是不能构造其他模块的结构体资源。</p>
<pre><code class="language-solidity">// Move编译器报错
┌─ /sources/m.move:25:31
   │
25 │         coin::publish_coin&lt;X&gt;(X {}); 
   │                               ^^^^ Invalid instantiation of '(examples=0x1)::xcoin::X'.
All structs can only be constructed in the module in which they are declared
</code></pre>
<h2 id="如何使用-2"><a class="header" href="#如何使用-2">如何使用</a></h2>
<p>witness在Sui中与其他Move公链有一些区别。</p>
<p>如果结构类型与定义它的模块名称相同且是大写，并且没有字段或者只有一个布尔字段，则意味着它是一个one-time witness类型。该类型只会在模块初始化时使用，在合约中验证是否是one-time witness类型，可以通过sui framwork中<a href="https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/sources/types.move#L10">types::is_one_time_witness</a>来验证。</p>
<p>例如在sui的coin库中，如果需要注册一个coin类型，那么需要调用<a href="https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/sources/coin.move#L176">create_currency</a>函数。函数参数则就需要一个one-time witness类型。为了传递该类型参数，需要在模块初始化<code>init</code>函数参数中第一个位置传递，即：</p>
<pre><code class="language-solidity">// 注册一个M_COIN类型的通用Token
module examples::m_coin {
    use sui::coin;
    use sui::transfer;
    use sui::tx_context::{Self, TxContext};

		// 必须是模块名大写字母
    struct M_COIN has drop{}

		// 第一个位置传递
    fun init (witness: M, ctx: &amp;mut TxContext) {
        let cap = coin::create_currency(witness, 8, ctx);
        transfer::transfer(cap, tx_context::sender(ctx));
    }
}
</code></pre>
<p>sui中的初始化函数只能有一个或者两个参数，且最后的参数一定是<code>&amp;mut TxContext</code>类型，one-time witness类型同样是模块初始化时自动传递的。</p>
<blockquote>
<p><code>init</code>函数如果传递除了上述提到的以外的参数，Move编译器能够编译通过，但是部署时Sui的验证器会报错。此外如果第一个传递的参数不是one-time witness类型，同样也只会在部署时Sui验证才会报错。</p>
</blockquote>
<h2 id="总结-2"><a class="header" href="#总结-2">总结</a></h2>
<p>witness模式通常其他模式一同使用，例如Wrapper和capability模式。</p>
<p>除了在sui的coin标准库中使用到了wintess，以下例子同样也有使用到：</p>
<ul>
<li><a href="https://github.com/MystenLabs/sui/blob/main/sui_programmability/examples/defi/sources/pool.move">Liquidity pool</a></li>
<li><a href="https://github.com/MystenLabs/sui/blob/main/sui_programmability/examples/fungible_tokens/sources/regulated_coin.move">Regulated coin</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hot-potato"><a class="header" href="#hot-potato">Hot Potato</a></h1>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Name</strong></td><td>Hot Potato</td></tr>
<tr><td><strong>Origin</strong></td><td><a href="https://github.com/MystenLabs/sui/blob/20e68787b3ace2b408ba0c1d8d9117fc5206cb05/sui_programmability/examples/defi/sources/FlashLender.move#L19">Sui Project</a> / <a href="https://github.com/tnowacki">Todd Nowacki</a></td></tr>
<tr><td><strong>Example</strong></td><td><a href="https://github.com/MystenLabs/sui/blob/a6156aeaf332b9f257cf04063a9a751a7a431360/sui_programmability/examples/defi/sources/flash_lender.move">FlashLender.move</a></td></tr>
<tr><td><strong>Depends on</strong></td><td>None</td></tr>
<tr><td><strong>Known to work on</strong></td><td>Move</td></tr>
</tbody></table>
</div>
<h2 id="概述-3"><a class="header" href="#概述-3">概述</a></h2>
<p>Hot Potato模式受益于Move中的Ability，Hot Potato是一个没有<code>key</code>、<code>store</code>和<code>drop</code>能力的结构，强制该结构在创建它的模块中使用掉。这种模式在闪电贷款这样的需要原子性的程序中是理想的，因为在同一交易中必须启动和偿还贷款。</p>
<pre><code class="language-move">struct Hot_Potato {}
</code></pre>
<p>相较于Solidity中的闪电贷的实现，Move中的实现是优雅的。在Solidity中会涉及到较多的动态调用，并且存在重入，拒绝服务攻击等问题。但在Move中，当函数返回了一个不具有任何的ability的potato时，由于没有drop的ability也，所以没办法储存到全局里面去，也没有办法去储存到其他结构体中。在函数结束的时也不能丢弃，所以必须解构这个资源，或者传给另外一个可以使用这个potato的一个函数。</p>
<p>所以通过这个方式，可以来实现函数的调用流程。模块可以在没有调用者任何背景和条件下，<strong>保证调用者一定会按照预先设定的顺序去调用函数</strong>。</p>
<blockquote>
<p>闪电贷本质也是一个调用顺序的问题</p>
</blockquote>
<h2 id="如何使用-3"><a class="header" href="#如何使用-3">如何使用</a></h2>
<h3 id="aptos-2"><a class="header" href="#aptos-2">Aptos</a></h3>
<p>Aptos上<a href="https://github.com/pontem-network/liquidswap/blob/main/sources/swap/liquidity_pool.move#L99">Liqudswasp</a>项目实现了FlashLoan，这里提取了核心的代码。</p>
<pre><code class="language-move">public fun flashloan&lt;X, Y, Curve&gt;(x_loan: u64, y_loan: u64): (Coin&lt;X&gt;, Coin&lt;Y&gt;, Flashloan&lt;X, Y, Curve&gt;)
    acquires LiquidityPool, EventsStore {
        let pool = borrow_global_mut&lt;LiquidityPool&lt;X, Y, Curve&gt;&gt;(@liquidswap_pool_account);
        ...
        let reserve_x = coin::value(&amp;pool.coin_x_reserve);
        let reserve_y = coin::value(&amp;pool.coin_y_reserve);
        // Withdraw expected amount from reserves.
        let x_loaned = coin::extract(&amp;mut pool.coin_x_reserve, x_loan);
        let y_loaned = coin::extract(&amp;mut pool.coin_y_reserve, y_loan);
        ...
        // Return loaned amount.
        (x_loaned, y_loaned, Flashloan&lt;X, Y, Curve&gt; { x_loan, y_loan })
    }

public fun pay_flashloan&lt;X, Y, Curve&gt;(
        x_in: Coin&lt;X&gt;,
        y_in: Coin&lt;Y&gt;,
        loan: Flashloan&lt;X, Y, Curve&gt;
    ) acquires LiquidityPool, EventsStore {
        ...
        let Flashloan { x_loan, y_loan } = loan;

        let x_in_val = coin::value(&amp;x_in);
        let y_in_val = coin::value(&amp;y_in);

        let pool = borrow_global_mut&lt;LiquidityPool&lt;X, Y, Curve&gt;&gt;(@liquidswap_pool_account);

        let x_reserve_size = coin::value(&amp;pool.coin_x_reserve);
        let y_reserve_size = coin::value(&amp;pool.coin_y_reserve);

        // Reserve sizes before loan out
        x_reserve_size = x_reserve_size + x_loan;
        y_reserve_size = y_reserve_size + y_loan;

        // Deposit new coins to liquidity pool.
        coin::merge(&amp;mut pool.coin_x_reserve, x_in);
        coin::merge(&amp;mut pool.coin_y_reserve, y_in);
        ...
    }
</code></pre>
<h3 id="sui-2"><a class="header" href="#sui-2">Sui</a></h3>
<p>sui<a href="https://github.com/MystenLabs/sui/blob/main/sui_programmability/examples/defi/sources/flash_lender.move">官方示例</a>中同样实现了闪电贷。</p>
<p>当用户借款时调用<code>loan</code>函数返回一笔资金<code>coin</code>和一个记录着借贷金额<code>value</code>但没有任何<code>ability</code>的<code>receipt</code>收据，如果用户试图不归还资金，那么这个收据将被丢弃从而报错，所以必须调用<code>repay</code>函数从而销毁收据。收据的销毁完全由模块控制，销毁时验证传入的金额是否等于收据中的金额，从而保证闪电贷的逻辑正确。</p>
<pre><code class="language-move">module example::flash_lender {
    use sui::balance::{Self, Balance};
    use sui::coin::{Self, Coin};
    use sui::object::{Self, ID, UID};
    use sui::transfer;
    use sui::tx_context::{Self, TxContext};

    /// A shared object offering flash loans to any buyer willing to pay `fee`.
    struct FlashLender&lt;phantom T&gt; has key {
        id: UID,
        /// Coins available to be lent to prospective borrowers
        to_lend: Balance&lt;T&gt;,
        /// Number of `Coin&lt;T&gt;`'s that will be charged for the loan.
        /// In practice, this would probably be a percentage, but
        /// we use a flat fee here for simplicity.
        fee: u64,
    }

    /// A &quot;hot potato&quot; struct recording the number of `Coin&lt;T&gt;`'s that
    /// were borrowed. Because this struct does not have the `key` or
    /// `store` ability, it cannot be transferred or otherwise placed in
    /// persistent storage. Because it does not have the `drop` ability,
    /// it cannot be discarded. Thus, the only way to get rid of this
    /// struct is to call `repay` sometime during the transaction that created it,
    /// which is exactly what we want from a flash loan.
    struct Receipt&lt;phantom T&gt; {
        /// ID of the flash lender object the debt holder borrowed from
        flash_lender_id: ID,
        /// Total amount of funds the borrower must repay: amount borrowed + the fee
        repay_amount: u64
    }

    /// An object conveying the privilege to withdraw funds from and deposit funds to the
    /// `FlashLender` instance with ID `flash_lender_id`. Initially granted to the creator
    /// of the `FlashLender`, and only one `AdminCap` per lender exists.
    struct AdminCap has key, store {
        id: UID,
        flash_lender_id: ID,
    }
    
    // === Creating a flash lender ===

    /// Create a shared `FlashLender` object that makes `to_lend` available for borrowing.
    /// Any borrower will need to repay the borrowed amount and `fee` by the end of the
    /// current transaction.
    public fun new&lt;T&gt;(to_lend: Balance&lt;T&gt;, fee: u64, ctx: &amp;mut TxContext): AdminCap {
        let id = object::new(ctx);
        let flash_lender_id = object::uid_to_inner(&amp;id);
        let flash_lender = FlashLender { id, to_lend, fee };
        // make the `FlashLender` a shared object so anyone can request loans
        transfer::share_object(flash_lender);

        // give the creator admin permissions
        AdminCap { id: object::new(ctx), flash_lender_id }
    }

    // === Core functionality: requesting a loan and repaying it ===

    /// Request a loan of `amount` from `lender`. The returned `Receipt&lt;T&gt;` &quot;hot potato&quot; ensures
    /// that the borrower will call `repay(lender, ...)` later on in this tx.
    /// Aborts if `amount` is greater that the amount that `lender` has available for lending.
    public fun loan&lt;T&gt;(
        self: &amp;mut FlashLender&lt;T&gt;, amount: u64, ctx: &amp;mut TxContext
    ): (Coin&lt;T&gt;, Receipt&lt;T&gt;) {
        let to_lend = &amp;mut self.to_lend;
        assert!(balance::value(to_lend) &gt;= amount, ELoanTooLarge);
        let loan = coin::take(to_lend, amount, ctx);
        let repay_amount = amount + self.fee;
        let receipt = Receipt { flash_lender_id: object::id(self), repay_amount };

        (loan, receipt)
    }

    /// Repay the loan recorded by `receipt` to `lender` with `payment`.
    /// Aborts if the repayment amount is incorrect or `lender` is not the `FlashLender`
    /// that issued the original loan.
    public fun repay&lt;T&gt;(self: &amp;mut FlashLender&lt;T&gt;, payment: Coin&lt;T&gt;, receipt: Receipt&lt;T&gt;) {
        let Receipt { flash_lender_id, repay_amount } = receipt;
        assert!(object::id(self) == flash_lender_id, ERepayToWrongLender);
        assert!(coin::value(&amp;payment) == repay_amount, EInvalidRepaymentAmount);

        coin::put(&amp;mut self.to_lend, payment)
    }
}
</code></pre>
<h2 id="总结-3"><a class="header" href="#总结-3">总结</a></h2>
<p>Hot Potato设计模式不仅仅只适用于闪电贷的场景，还可以用来控制更复杂的函数调用顺序。</p>
<p>例如我们想要一个制作土豆的合约，当用户调用<code>get_potato</code>时，会得到一个没有任何能力的<code>potato</code>，我们想要用户得倒之后，按照切土豆、煮土豆最后才能吃土豆的一个既定流程来操作。所以用户为了完成交易那么必须最后调用<code>consume_potato</code>，但是该函数限制了土豆必须被<code>cut</code>和<code>cook</code>，所以需要分别调用<code>cut_potato</code>和<code>cook_potato</code>，<code>cook_potato</code>中又限制了必须先被<code>cut</code>，从而合约保证了调用顺序必须为get→cut→cook→consume，从而控制了调用顺序。</p>
<pre><code class="language-move">module example::hot_potato {
    /// Without any capability,
    struct Potato {
        has_cut: bool,
        has_cook: bool,
    }
    /// When calling this function, the `sender` will receive a `Potato` object.
    /// The `sender` can do nothing with the `Potato` such as store, drop,
    /// or move_to the global storage, except passing it to `consume_potato` function.
    public fun get_potato(_sender: &amp;signer): Potato {
        Potato {
            has_cut: false,
            has_cook: false,
        } 
    }

    public fun cut_potatoes(potato: &amp;mut Potato) {
        assert!(!potato.has_cut, 0);
        potato.has_cut = true;
    }

    public fun cook_potato(potato: &amp;mut Potato) {
        assert!(!potato.has_cook &amp;&amp; potato.has_cut, 0);
        potato.has_cook = true;
    }

    public fun consume_potato(_sender: &amp;signer, potato: Potato) {
        assert!(potato.has_cook &amp;&amp; potato.has_cut, 0);
        let Potato {has_cut: _, has_cook: _ } = potato; // destroy the Potato.
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiple-configurations"><a class="header" href="#multiple-configurations">Multiple Configurations</a></h1>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Name</strong></td><td>Multiple Configurations</td></tr>
<tr><td><strong>Origin</strong></td><td><a href="https://github.com/villesundell">Ville Sundell</a></td></tr>
<tr><td><strong>Example</strong></td><td><a href="https://web.archive.org/web/20211130211815/https://community.diem.com/t/multiple-configurations-approach-a-possible-design-pattern/3485">Diem Forum Post</a></td></tr>
<tr><td><strong>Depends on</strong></td><td>None</td></tr>
<tr><td><strong>Known to work on</strong></td><td>Move</td></tr>
</tbody></table>
</div>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>In the <strong>Multiple Configurations</strong> approach singletons (especially for configuration data) are provided to the module as arguments instead of storing them to any specific location. </p>
<p>By incorporating this design into your modules, you would automatically add a layer of configurability by giving users or admins (if any) a way to create configurations which others could use. This would be similar to Uniswap which lets anyone create markets others could participate in.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>Let's say you have an auction smart contract X and an admin has created a configuration to account A. Then B could issue a transaction script to bid on C's resource like this:</p>
<pre><code class="language-move">X::place_bid(A, C, 1234);
</code></pre>
<p>By accepting parameters (such as C and the amount 1234), a transaction script could trivially hide the selection of the configuration. This depends, how flexible the final script implementation is in terms of arguments to <code>main()</code>, but the transaction script could look like this (quick mock-up):</p>
<pre><code class="language-move">script {
    use 0xFF::X;

    const CONF: address = 0xCOFFEE;

    fun main(a: address, amount: XUS) {
        X::place_bid(CONF, a, amount);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accountless-design"><a class="header" href="#accountless-design">Accountless Design</a></h1>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Name</strong></td><td>Accountless Design</td></tr>
<tr><td><strong>Origin</strong></td><td><a href="https://github.com/villesundell">Ville Sundell</a></td></tr>
<tr><td><strong>Example</strong></td><td><a href="https://web.archive.org/web/20220202065315/https://community.diem.com/t/outbox-an-alternative-way-to-store-resources/3737">Diem Forum Post</a></td></tr>
<tr><td><strong>Depends on</strong></td><td>None</td></tr>
<tr><td><strong>Known to work on</strong></td><td>Move</td></tr>
</tbody></table>
</div>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>Move module following the <strong>Accountless Design</strong> pattern doesn't handle storage (<code>move_to()</code> / <code>move_from()</code>) directly, instead the storage must be handled outside the module in transaction scripts. This makes the module code footprint smaller, design simpler, implementation more portable and provides a way to implement storage agnostic smart contract design on some Move powered platforms.</p>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<pre><code class="language-move">module 0x1::Outbox {
    use Std::Event;
    use Std::Signer;
    use Std::Vector;

    struct Item&lt;Content: key + store&gt; has key, store {
        from: address,
        to: address,
        content: Content
    }

    struct Outbox&lt;Content: key + store&gt; has key, store {
        content: vector&lt;Item&lt;Content&gt;&gt;
    }

    struct Put&lt;phantom Content&gt; has key, drop, store {
    }

    struct EventHandle&lt;phantom Content: drop + store&gt; has key, store {
        event_handle: Event::EventHandle&lt;Content&gt;
    }

    public fun create&lt;Content: key + store&gt;(account: &amp;signer) {
        move_to&lt;Outbox&lt;Content&gt;&gt;(account, Outbox&lt;Content&gt; { content: Vector::empty&lt;Item&lt;Content&gt;&gt;() });
        move_to&lt;EventHandle&lt;Put&lt;Content&gt;&gt;&gt;(account, EventHandle&lt;Put&lt;Content&gt;&gt; { event_handle: Event::new_event_handle&lt;Put&lt;Content&gt;&gt;(account) } );
    }

    public fun put&lt;Content: key + store&gt;(account: &amp;signer, from: address, to: address, content: Content) acquires EventHandle, Outbox {
        let outbox_owner = Signer::address_of(account);
        let event_handle = borrow_global_mut&lt;EventHandle&lt;Put&lt;Content&gt;&gt;&gt;(outbox_owner);
        let outbox = borrow_global_mut&lt;Outbox&lt;Content&gt;&gt;(outbox_owner);

        assert!(to != @0x0, 123);

        Vector::push_back&lt;Item&lt;Content&gt;&gt;(&amp;mut outbox.content, Item&lt;Content&gt;{ from, to, content });
        Event::emit_event&lt;Put&lt;Content&gt;&gt;(&amp;mut event_handle.event_handle, Put&lt;Content&gt; {});
    }

    public fun get&lt;Content: key + store&gt;(account: &amp;signer, outbox_owner: address, index: u64): Content acquires Outbox {
        let account_addr = Signer::address_of(account);
        let outbox = borrow_global_mut&lt;Outbox&lt;Content&gt;&gt;(outbox_owner);

        let Item&lt;Content&gt;{from, to, content} = Vector::swap_remove&lt;Item&lt;Content&gt;&gt;(&amp;mut outbox.content, index);

        assert!(from == account_addr || to == account_addr, 123);

        content
    }
}
</code></pre>
<p><em>Now <code>Outbox</code> can be used to retrieve and store resources in transaction scripts, and pass those to modules following the <a href="./script_based_design.html">Script Based Design</a> pattern.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="script-based-design"><a class="header" href="#script-based-design">Script Based Design</a></h1>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Name</strong></td><td>Script Based Design</td></tr>
<tr><td><strong>Origin</strong></td><td><a href="https://github.com/villesundell">Ville Sundell</a></td></tr>
<tr><td><strong>Example</strong></td><td>Diem Forum post lost, April 18 2022</td></tr>
<tr><td><strong>Depends on</strong></td><td><a href="./accountless_design.html">Accountless Design</a></td></tr>
<tr><td><strong>Known to work on</strong></td><td>Move</td></tr>
</tbody></table>
</div>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p><strong>Script Based Design</strong> combines <a href="./accountless_design.html">Accountless Design</a> with <em>Move Transaction Scripts</em> enabling a design where most of the business logic resides in transaction scripts, while keeping the most critical parts in modules. This way the transaction scripts can be developed and improved faster than a regular module would, while providing the same kind of guarantees as regular modules by keeping the most critical part (state transitions) in modules.</p>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transferable-witness"><a class="header" href="#transferable-witness">Transferable Witness</a></h1>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Name</strong></td><td>Transferable Witness</td></tr>
<tr><td><strong>Origin</strong></td><td><a href="https://examples.sui.io/patterns/transferable-witness.html">Sui Move by Example</a> / <a href="https://github.com/damirka">Damir Shamanaev</a></td></tr>
<tr><td><strong>Example</strong></td><td><a href="https://examples.sui.io/patterns/transferable-witness.html">Sui Move by Example</a> / <a href="https://github.com/damirka">Damir Shamanaev</a></td></tr>
<tr><td><strong>Depends on</strong></td><td><a href="./capability.html">Capability</a>, <a href="./witness.html">Witness</a></td></tr>
<tr><td><strong>Known to work on</strong></td><td>Move</td></tr>
</tbody></table>
</div>
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<p>A <strong>Transferable Witness</strong> is a semi-ephemeral storable <a href="./witness.html">witness</a> wrapped into a disposable <a href="./capability.html">capability</a>. </p>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<pre><code class="language-move">/// This pattern is based on combination of two others: Capability and a Witness.
/// Since Witness is something to be careful with, spawning it should be only
/// allowed to authorized users (ideally only once). But some scenarios require
/// type authorization by module X to be used in another module Y. Or, possibly,
/// there's a case where authorization should be performed after some time.
///
/// For these, rather rare, scerarios a storable witness is a perfect solution.
module examples::transferable_witness {
    use sui::transfer;
    use sui::id::{Self, VersionedID};
    use sui::tx_context::{Self, TxContext};

    /// Witness now has a `store` which allows us to store it inside a wrapper.
    struct WITNESS has store, drop {}

    /// Carries the witness type. Can only be used once to get a Witness.
    struct WitnessCarrier has key { id: VersionedID, witness: WITNESS }

    /// Send a `WitnessCarrier` to the module publisher.
    fun init(ctx: &amp;mut TxContext) {
        transfer::transfer(
            WitnessCarrier { id: tx_context::new_id(ctx), witness: WITNESS {} },
            tx_context::sender(ctx)
        )
    }

    /// Unwrap a carrier and get the inner WITNESS type.
    public fun get_witness(carrier: WitnessCarrier): WITNESS {
        let WitnessCarrier { id, witness } = carrier;
        id::delete(id);
        witness
    }
}
</code></pre>
<p><em>Example for Sui Move is taken from the book <a href="https://examples.sui.io/patterns/transferable-witness.html">Sui Move by Example</a> by <a href="https://github.com/damirka">Damir Shamanaev</a>.</em></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
